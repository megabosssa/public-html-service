<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Drive - Open World</title>
    <link rel="icon" type="image/svg+xml" href="../assets/images/favicon.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #1a1a2e;
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            pointer-events: none;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px 20px;
            color: white;
            margin-bottom: 10px;
        }

        .speed-display {
            font-size: 48px;
            font-weight: 800;
            line-height: 1;
        }

        .speed-unit {
            font-size: 14px;
            color: #888;
            margin-left: 5px;
        }

        .coords {
            font-size: 12px;
            color: #888;
            font-family: monospace;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Menu */
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        h1 {
            font-size: 72px;
            font-weight: 300;
            color: white;
            margin-bottom: 10px;
            letter-spacing: -2px;
        }

        h1 span {
            font-weight: 800;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .tagline {
            font-size: 18px;
            color: #666;
            margin-bottom: 50px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .start-btn {
            background: linear-gradient(135deg, #00d4ff, #00aa88);
            color: #000;
            border: none;
            padding: 18px 60px;
            font-size: 18px;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.4);
        }

        .controls-info {
            margin-top: 50px;
            color: #555;
            text-align: center;
            line-height: 2;
        }

        .key {
            display: inline-block;
            padding: 5px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            margin: 0 5px;
        }

        .hidden {
            display: none !important;
        }

        /* Instructions overlay */
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-panel">
            <div class="speed-display"><span id="speed">0</span><span class="speed-unit">KM/H</span></div>
        </div>
        <div class="hud-panel">
            <div class="coords">X: <span id="pos-x">0</span> | Z: <span id="pos-z">0</span></div>
        </div>
    </div>

    <!-- Minimap -->
    <div id="minimap">
        <canvas id="minimap-canvas" width="200" height="200"></canvas>
    </div>

    <!-- Menu -->
    <div id="menu">
        <h1>City<span>Drive</span></h1>
        <div class="tagline">Open World Experience</div>
        <button class="start-btn" onclick="game.start()">Explore City</button>
        <div class="controls-info">
            <span class="key">W</span> Accelerate &nbsp;&nbsp;
            <span class="key">S</span> Brake / Reverse<br>
            <span class="key">A</span> <span class="key">D</span> Steer &nbsp;&nbsp;
            <span class="key">SPACE</span> Handbrake
        </div>
    </div>

    <div id="instructions">Use W A S D to drive around the city freely!</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ============ OPEN WORLD CITY GAME ============
        class OpenWorldGame {
            constructor() {
                this.container = document.getElementById('game-container');

                // Three.js
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0xc8e0f0, 100, 500);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);

                // Lighting
                const hemi = new THREE.HemisphereLight(0x87CEEB, 0x3a5f0b, 0.6);
                this.scene.add(hemi);

                const sun = new THREE.DirectionalLight(0xfffaf0, 1.0);
                sun.position.set(100, 150, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 4096;
                sun.shadow.mapSize.height = 4096;
                sun.shadow.camera.near = 10;
                sun.shadow.camera.far = 400;
                sun.shadow.camera.left = -150;
                sun.shadow.camera.right = 150;
                sun.shadow.camera.top = 150;
                sun.shadow.camera.bottom = -150;
                this.scene.add(sun);

                const ambient = new THREE.AmbientLight(0xffffff, 0.3);
                this.scene.add(ambient);

                // City Config
                this.citySize = 10; // 10x10 blocks
                this.blockSize = 40; // Each block is 40 units
                this.roadWidth = 12;

                // Build World
                this.createGround();
                this.createCity();
                this.createPlayer();

                // Game State
                this.running = false;
                this.carSpeed = 0;
                this.carAngle = 0; // Radians
                this.maxSpeed = 80;
                this.reverseMaxSpeed = 30;

                // Input
                this.keys = { w: false, a: false, s: false, d: false, space: false };
                this.setupInput();

                // Minimap
                this.minimapCtx = document.getElementById('minimap-canvas').getContext('2d');

                // Loop
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);

                // Resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Hide instructions after 5 seconds
                setTimeout(() => {
                    document.getElementById('instructions').style.opacity = '0';
                }, 5000);
            }

            createGround() {
                const size = this.citySize * this.blockSize * 2;
                const geo = new THREE.PlaneGeometry(size, size);
                const mat = new THREE.MeshStandardMaterial({ color: 0x3d8c40, roughness: 1 }); // Grass
                const ground = new THREE.Mesh(geo, mat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.1;
                ground.receiveShadow = true;
                this.scene.add(ground);
            }

            createCity() {
                const halfCity = (this.citySize * this.blockSize) / 2;

                // Road materials
                const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
                const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.9 });

                // Create grid of roads
                for (let i = 0; i <= this.citySize; i++) {
                    const pos = i * this.blockSize - halfCity;

                    // Horizontal road
                    const hRoad = new THREE.Mesh(
                        new THREE.PlaneGeometry(this.citySize * this.blockSize + this.roadWidth, this.roadWidth),
                        roadMat
                    );
                    hRoad.rotation.x = -Math.PI / 2;
                    hRoad.position.set(0, 0.01, pos);
                    hRoad.receiveShadow = true;
                    this.scene.add(hRoad);

                    // Vertical road
                    const vRoad = new THREE.Mesh(
                        new THREE.PlaneGeometry(this.roadWidth, this.citySize * this.blockSize + this.roadWidth),
                        roadMat
                    );
                    vRoad.rotation.x = -Math.PI / 2;
                    vRoad.position.set(pos, 0.01, 0);
                    vRoad.receiveShadow = true;
                    this.scene.add(vRoad);

                    // Road lines
                    this.addRoadLines(pos, 'horizontal');
                    this.addRoadLines(pos, 'vertical');
                }

                // Create buildings in each block
                const buildingColors = [0xe8e8e8, 0xd0d0d0, 0xc8d8e8, 0xf0e8e0, 0xe0e8f0, 0xd8e8d8];

                for (let bx = 0; bx < this.citySize; bx++) {
                    for (let bz = 0; bz < this.citySize; bz++) {
                        const blockCenterX = bx * this.blockSize - halfCity + this.blockSize / 2;
                        const blockCenterZ = bz * this.blockSize - halfCity + this.blockSize / 2;

                        // Random number of buildings per block (1-4)
                        const numBuildings = 1 + Math.floor(Math.random() * 3);

                        for (let b = 0; b < numBuildings; b++) {
                            const w = 8 + Math.random() * 12;
                            const d = 8 + Math.random() * 12;
                            const h = 15 + Math.random() * 50;

                            const offsetX = (Math.random() - 0.5) * (this.blockSize - this.roadWidth - w - 4);
                            const offsetZ = (Math.random() - 0.5) * (this.blockSize - this.roadWidth - d - 4);

                            const building = new THREE.Mesh(
                                new THREE.BoxGeometry(w, h, d),
                                new THREE.MeshStandardMaterial({
                                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                                    roughness: 0.3,
                                    metalness: 0.1
                                })
                            );
                            building.position.set(
                                blockCenterX + offsetX,
                                h / 2,
                                blockCenterZ + offsetZ
                            );
                            building.castShadow = true;
                            building.receiveShadow = true;
                            this.scene.add(building);

                            // Add windows
                            this.addWindows(building, w, h, d);
                        }
                    }
                }

                // Add some trees along sidewalks
                for (let i = 0; i < 200; i++) {
                    const x = (Math.random() - 0.5) * this.citySize * this.blockSize;
                    const z = (Math.random() - 0.5) * this.citySize * this.blockSize;

                    // Only place trees not on roads
                    const onRoadX = Math.abs(x % this.blockSize) < this.roadWidth / 2 + 2;
                    const onRoadZ = Math.abs(z % this.blockSize) < this.roadWidth / 2 + 2;

                    if (!onRoadX && !onRoadZ) {
                        this.addTree(x, z);
                    }
                }
            }

            addRoadLines(pos, direction) {
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 }); // Yellow center line
                const lineGeo = new THREE.PlaneGeometry(0.3, this.citySize * this.blockSize);

                if (direction === 'horizontal') {
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.rotation.x = -Math.PI / 2;
                    line.rotation.z = Math.PI / 2;
                    line.position.set(0, 0.02, pos);
                    this.scene.add(line);
                } else {
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(pos, 0.02, 0);
                    this.scene.add(line);
                }
            }

            addWindows(building, w, h, d) {
                const windowMat = new THREE.MeshBasicMaterial({ color: 0x88ccee });
                const floors = Math.floor(h / 4);

                // Front and back
                for (let floor = 0; floor < floors; floor++) {
                    const cols = Math.floor(w / 3);
                    for (let col = 0; col < cols; col++) {
                        if (Math.random() > 0.3) {
                            const win = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2), windowMat);
                            win.position.set(
                                building.position.x - w / 2 + 2 + col * 3,
                                2 + floor * 4,
                                building.position.z + d / 2 + 0.1
                            );
                            this.scene.add(win);

                            const winBack = win.clone();
                            winBack.position.z = building.position.z - d / 2 - 0.1;
                            winBack.rotation.y = Math.PI;
                            this.scene.add(winBack);
                        }
                    }
                }
            }

            addTree(x, z) {
                const tree = new THREE.Group();

                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 3, 8),
                    new THREE.MeshStandardMaterial({ color: 0x5d4037 })
                );
                trunk.position.y = 1.5;
                trunk.castShadow = true;
                tree.add(trunk);

                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(2.5, 8, 6),
                    new THREE.MeshStandardMaterial({ color: 0x2e7d32 })
                );
                foliage.position.y = 4.5;
                foliage.castShadow = true;
                tree.add(foliage);

                tree.position.set(x, 0, z);
                this.scene.add(tree);
            }

            createPlayer() {
                this.player = new THREE.Group();

                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xcc0000,
                    roughness: 0.2,
                    metalness: 0.8
                });

                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 4.5), bodyMat);
                body.position.y = 0.6;
                body.castShadow = true;
                this.player.add(body);

                // Cabin
                const cabin = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.5, 2),
                    new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0, metalness: 0.9 })
                );
                cabin.position.set(0, 1.1, -0.3);
                cabin.castShadow = true;
                this.player.add(cabin);

                // Wheels
                const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                [[1.1, 1.5], [-1.1, 1.5], [1.1, -1.5], [-1.1, -1.5]].forEach(([x, z]) => {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(x, 0.4, z);
                    wheel.castShadow = true;
                    this.player.add(wheel);
                });

                // Headlights
                const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffdd });
                [-0.7, 0.7].forEach(x => {
                    const hl = new THREE.Mesh(new THREE.CircleGeometry(0.2), hlMat);
                    hl.position.set(x, 0.5, -2.26);
                    hl.rotation.y = Math.PI;
                    this.player.add(hl);
                });

                // Tail lights
                const tlMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                [-0.7, 0.7].forEach(x => {
                    const tl = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.15, 0.05), tlMat);
                    tl.position.set(x, 0.5, 2.26);
                    this.player.add(tl);
                });

                this.player.position.set(0, 0, 0);
                this.scene.add(this.player);
            }

            setupInput() {
                const handleKey = (e, down) => {
                    const k = e.key.toLowerCase();
                    if (k === 'w' || k === 'arrowup') this.keys.w = down;
                    if (k === 's' || k === 'arrowdown') this.keys.s = down;
                    if (k === 'a' || k === 'arrowleft') this.keys.a = down;
                    if (k === 'd' || k === 'arrowright') this.keys.d = down;
                    if (k === ' ') this.keys.space = down;
                };
                window.addEventListener('keydown', e => handleKey(e, true));
                window.addEventListener('keyup', e => handleKey(e, false));
            }

            start() {
                document.getElementById('menu').classList.add('hidden');
                this.running = true;
            }

            loop() {
                requestAnimationFrame(this.loop);

                if (this.running) {
                    const dt = 0.016;

                    // === Car Physics ===
                    // Acceleration / Braking
                    if (this.keys.w) {
                        this.carSpeed += 30 * dt;
                    } else if (this.keys.s) {
                        if (this.carSpeed > 0) {
                            this.carSpeed -= 50 * dt; // Brake
                        } else {
                            this.carSpeed -= 20 * dt; // Reverse
                        }
                    } else {
                        // Coast / friction
                        if (this.carSpeed > 0) this.carSpeed -= 10 * dt;
                        else if (this.carSpeed < 0) this.carSpeed += 10 * dt;
                        if (Math.abs(this.carSpeed) < 0.5) this.carSpeed = 0;
                    }

                    // Handbrake
                    if (this.keys.space) {
                        this.carSpeed *= 0.95;
                    }

                    // Clamp speed
                    this.carSpeed = Math.max(-this.reverseMaxSpeed, Math.min(this.carSpeed, this.maxSpeed));

                    // Steering (only when moving)
                    if (Math.abs(this.carSpeed) > 1) {
                        const turnSpeed = 2.0 * (this.carSpeed / this.maxSpeed);
                        if (this.keys.a) this.carAngle += turnSpeed * dt * (this.carSpeed > 0 ? 1 : -1);
                        if (this.keys.d) this.carAngle -= turnSpeed * dt * (this.carSpeed > 0 ? 1 : -1);
                    }

                    // Move car
                    const moveX = Math.sin(this.carAngle) * this.carSpeed * dt;
                    const moveZ = Math.cos(this.carAngle) * this.carSpeed * dt;
                    this.player.position.x -= moveX;
                    this.player.position.z -= moveZ;
                    this.player.rotation.y = this.carAngle;

                    // Camera follow (third person behind car)
                    const camDist = 12;
                    const camHeight = 6;
                    const targetCamX = this.player.position.x + Math.sin(this.carAngle) * camDist;
                    const targetCamZ = this.player.position.z + Math.cos(this.carAngle) * camDist;

                    this.camera.position.x = THREE.MathUtils.lerp(this.camera.position.x, targetCamX, 0.05);
                    this.camera.position.z = THREE.MathUtils.lerp(this.camera.position.z, targetCamZ, 0.05);
                    this.camera.position.y = THREE.MathUtils.lerp(this.camera.position.y, camHeight, 0.05);

                    this.camera.lookAt(this.player.position.x, 1, this.player.position.z);

                    // === HUD ===
                    document.getElementById('speed').innerText = Math.abs(Math.floor(this.carSpeed));
                    document.getElementById('pos-x').innerText = Math.floor(this.player.position.x);
                    document.getElementById('pos-z').innerText = Math.floor(this.player.position.z);

                    // Minimap
                    this.drawMinimap();
                }

                this.renderer.render(this.scene, this.camera);
            }

            drawMinimap() {
                const ctx = this.minimapCtx;
                const size = 200;
                const scale = 0.4; // How much of city to show

                ctx.fillStyle = '#1a472a';
                ctx.fillRect(0, 0, size, size);

                // Draw roads
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;

                const halfCity = (this.citySize * this.blockSize) / 2;
                const centerX = size / 2;
                const centerZ = size / 2;

                // Translate player position to minimap
                const mapX = centerX - (this.player.position.x * scale);
                const mapZ = centerZ - (this.player.position.z * scale);

                // Draw grid
                for (let i = 0; i <= this.citySize; i++) {
                    const pos = (i * this.blockSize - halfCity) * scale;

                    ctx.beginPath();
                    ctx.moveTo(mapX + pos, 0);
                    ctx.lineTo(mapX + pos, size);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0, mapZ + pos);
                    ctx.lineTo(size, mapZ + pos);
                    ctx.stroke();
                }

                // Draw player (red dot with direction)
                ctx.save();
                ctx.translate(centerX, centerZ);
                ctx.rotate(-this.carAngle);

                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(5, 5);
                ctx.lineTo(-5, 5);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        const game = new OpenWorldGame();
    </script>
</body>

</html>